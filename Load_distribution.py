import numpy as np
import math
import scipy as sp
from scipy.integrate import quad
from scipy.integrate import cumulative_trapezoid
import LoadCalculator as calc
import AerodynamicLoads as al
import fn

def internalcalculator(V_eas, h, n, fcheck, payload):

        # Parameters:
    g=9.81  #[m/s^2]
    b=44.3  #[m]
    surface_area = 187 #[m^2]
    engine_mass=118197*(0.101 + 0.023)/2  #[kg]
    engine_thrust = 233591  #[N]
    end_wet_wing= 14  #m
    fuel_mass=41161/2  #[kg]
    wing_mass=0.142*118197/2  #[kg]
    fuel_density=840  #kg/m^3
    c_r=6.53  #[m]
    c_t=1.91  #[m]
    ct=0.14  #thickness to chord ratio
    rho0 = 1.225  #sea level density
    engine_thrust_arm = 1.6  #m
    engine_y = 7.75  #m
    maximumpayload = 18960 #kg

    #get the relevant rows from the text files from XFLR 5
    data0 = np.genfromtxt('a0.txt', skip_header=21, skip_footer=1029, encoding='cp1252')
    data10 = np.genfromtxt('a10.txt', skip_header=21, skip_footer=1029, encoding='cp1252')

    #sort the text file and get lists for the span-wise location, chord length, Cl, Cd, Cm.
    ylst0, chlst0, cllst0, cdlst0, cmlst0= al.AL_sorter(data0)
    ylst10, chlst10, cllst10, cdlst10, cmlst10 = al.AL_sorter(data10)

    #Input all the necessary data
    plane_mass = 118197
    if fcheck:
        fuel = True
    else:
        plane_mass -= fuel_mass*2
        fuel = False
    if  not payload:
        plane_mass -= maximumpayload
    q = 1/2 * rho0 * V_eas **2  #dynamic pressure
    CL = n*plane_mass*g/(q*surface_area)

    #Convert the previously obtained distributions into one matching the calculated CL
    Cl = al.AL_specific(cllst0, cllst10, CL)
    Cm = al.AL_specific(cmlst0, cmlst10, CL)
    Cd = al.AL_specific(cdlst0, cdlst10, CL)

    #Turn the lists into continuous functions
    Ld = sp.interpolate.interp1d(ylst10, Cl * q * chlst0, kind='cubic', fill_value='extrapolate')
    Md = sp.interpolate.interp1d(ylst10, Cm * q * chlst0**2, kind='cubic', fill_value='extrapolate')
    Dd = sp.interpolate.interp1d(ylst10, Cd * q * chlst0, kind='cubic', fill_value='extrapolate')
    Ch = sp.interpolate.interp1d(ylst10, chlst0, kind='cubic', fill_value='extrapolate')

    #Consider the safety factor and the load factor for inertial loads
    ng = n * g
    sf = 1.5

    #Define the normal aerodynamic force distribution
    def N(L, D, a):
        def f(x):
            return L(x)*np.cos(a)+D(x)*np.sin(a)
        return f
    aoa = math.radians(al.AL_computeaoa(CL))
    Nd = N(Ld, Dd, aoa)

    ''' Creating the load diagram for the half wing span. First we define functions calculated previously and integrate the over 
    half wingspan. Then we add point loads. '''

    #Declare the weight distribution
    Wd = calc.weightdistribution2(wing_mass, b, Ch, ng)
    #Declare the total load distribution, which considers the normal aerodynamic distribution and the weight distribution
    loading = calc.load(b, ng, ct, c_r, c_t, end_wet_wing, fuel_density, aoa, Wd, Ld, Dd, fuel, sf)

    #Compute the point force generated by the engine weight
    E_force = calc.engine_weight(engine_mass, ng, engine_y)


    #compute internal shear loading
    def shear(L_end, P2_load, x2_loc, w_func, s):
        
        def S(x):
            # Define the Integral Function
            def integral_w(x_start, L_end, w_func):
                result, _ = quad(w_func, x_start, L_end)
                return result
        
            # 1. Integral Term
            integral_term = integral_w(x, L_end, w_func)

            # 2. Concentrated Load Term P * (1 - u_{x1}(x))
            # Heaviside: 1 for x >= x1_loc, 0 for x < x1_loc
            u_x2 = np.heaviside(x - x2_loc, 1.0)
        
            # Concentrated load term: P * (1 - u_{x1})
            concentrated_load_term = s * P2_load * (1 - u_x2)

            # The formula is -S(x) = -integral_term - concentrated_load_term
            negative_Sx = -integral_term - concentrated_load_term

            return -negative_Sx
        
        return S

    #compute internal bending moment
    def bending(L_end, M1, x1, w_func):
        
        def M(x):

            # Define the Integral Function
            def integral_w(x_start, L_end, w_func):
                result, _, info = quad(w_func, x_start, L_end, points=engine_y, full_output=True)
                return result
        
            # 1. Integral Term
            integral_term = integral_w(x, L_end, w_func)

            # 2. Concentrated Load Term P * (1 - u_{x1}(x))
            # Heaviside: 1 for x >= x1_loc, 0 for x < x1_loc
            u_x1 = np.heaviside(x - x1, 1.0)
        
            # Concentrated load term: P * (1 - u_{x1})
            concentrated_load_term = M1 * (1 - u_x1)

            # The formula is -S(x) = -integral_term - concentrated_load_term
            negative_My = integral_term + concentrated_load_term

            return -negative_My
        
        return M
    #the above are not actually used, as they take a lot of time compared to a vectorized code.

    #quad takes a very long time, so here is a vecrotized version of the previous.
    def build_diagramsSM(L_end, w_func, p2, x2, npts, M1, xm1, s):
        """
        Vectorized build of shear and moment diagrams.
        L_end : semi-span [m]
        w_func : callable, takes numpy array x, returns w(x) [N/m] (upwards positive)
        M1 : concentrated root-relief moment term as in your earlier formula
        x1 : where that moment/load is applied
        """
        # 1. Spanwise grid
        x = np.linspace(0.0, L_end, npts)
        w = np.zeros_like(x)        # create empty array for loads

        for i in range(len(x)):
            w[i] = w_func(x[i]) 

        # 3. Integral of w from 0 to x: W(x) = ∫_0^x w(s) ds
        W = cumulative_trapezoid(w, x, initial=0.0)

        # 4. Total integral ∫_0^L w(ξ) dξ is the last element
        total_W = W[-1]

        # 5. Integral from x_i to L:
        #    ∫_{x_i}^L w(ξ)dξ = ∫_0^L w - ∫_0^{x_i} w
        integral = total_W - W

        u_x2 = np.heaviside(x - x2, 1.0)
        concentrated_term = s * p2 * (1.0 - u_x2)

        negative_S = -integral + -concentrated_term
        S = -negative_S   # shear array, same as your old S(x)

        I = cumulative_trapezoid(S, x, initial=0.0)
        total_I = I[-1]
        integral2 = total_I - I

        u_xm1 = np.heaviside(x - xm1, 1.0)
        concentrated_termM = s * M1 * (1.0 - u_xm1)
        negative_M = integral2 + concentrated_termM
        M = -negative_M

        return x, S, M

    #use the function above to get the lists that describe the internal loadings
    x, SA, MA = build_diagramsSM(b/2, loading, E_force[1]*np.cos(aoa), E_force[0], 10000, engine_thrust*np.sin(np.radians(31)), engine_y, sf)

    #also, commented out, it would be used if the code werent vectorized.
    #interpolate the above to turn the list into a continuous function
    # S = sp.interpolate.interp1d(x, SA, kind='cubic', fill_value='extrapolate')
    # M = sp.interpolate.interp1d(x, MA, kind='cubic', fill_value='extrapolate')

    #compute the function d(y), which gives the distance between the a.c. and the flexural axis
    m = 0.2
    def d(f, C_func):
        def new_function(x):
            return f * C_func(x) + fn.WP4_2_wingbox_shape(x)[0][0] - 0.25 * C_func(x)
        return new_function
    d_f = d(m, Ch)

    #compute the internal torque 
    def torsion(L_end, q_func, d_func, t_func, We, e, a, F2, h, x2, ssf, npts):


        x = np.linspace(0.0, L_end, npts)
        q = np.zeros_like(x)        # create empty array for loads
        d = np.zeros_like(x)
        t = np.zeros_like(x)

        for i in range(len(x)):
            q[i] = q_func(x[i]) 
            d[i] = d_func(x[i])
            t[i] = t_func(x[i])

        I = ssf * (q * d + t)

        Int = cumulative_trapezoid(I, x, initial = 0.0)

        total_Int = Int[-1]
        
        integral = total_Int - Int

        u_x2 = np.heaviside(x - x2, 1.0)
        force_term = ssf * (- We * ( np.cos(a) * e + np.sin(a) * h) + F2 * h) * (1 - u_x2)

        tau_x = integral + force_term
        
        # def tau(x):

        #     def integrand(s):
        #         return ssf * (q_func(s) * d_func(s) + t_func(s))

        #     def integral_term(x_start, L_end):
        #         result, _ = quad(integrand, x_start, L_end)
        #         return result

        #     distributed_torsion = integral_term(x, L_end)

        #     u_x2 = np.heaviside(x - x2, 1.0)
        #     force_term = ssf * (- We * ( np.cos(a) * e + np.sin(a) * h) + F2 * h) * (1 - u_x2)

        #     #Total torsion
        #     tau_x = distributed_torsion + force_term

        #     return tau_x

        return tau_x

    #use the function above to get the function for the internal torque
    #Here Nd, is inputted instead of load, as Nd is offset from the shear centre, not the whole resultant.
    TA = torsion(b/2, Nd, d_f, Md, engine_mass*ng, 1.667+0.4*Ch(7.75), aoa, engine_thrust*np.cos(np.radians(31)), engine_thrust_arm, engine_y, sf, 10000) #For now distance from shear center is needed

    def normal(L_end, P1, x1, ssf, npts):

        x = np.linspace(0.0, L_end, npts)
        u_x1 = np.heaviside(x - x1, 1.0)
        N = ssf * P1 * (1 - u_x1)

        return N

    NA = normal(b/2, -engine_thrust*np.sin(np.radians(31)), engine_y, sf, 10000)

    return x, SA, MA, TA, NA

    